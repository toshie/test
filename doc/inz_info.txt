- zrodla:
  - wiki.osdev.org
  - https://littleosbook.github.io/
  - http://skelix.net/skelixos/tutorial03_en.html


------- tworzenie wirtualnego hdd
- https://linux.die.net/man/1/dd, bs=wielkosc "bloku"? count=ilosc blokow
- DOS partition table vs GPT:
  - https://en.wikipedia.org/wiki/GUID_Partition_Table
  - DOS = BIOS i MBR, GPT = UEFI
  - http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf

- przygotowanie dysku:
  - pusta przestrzen: dd if=/de:w
v/zero of=disk.img bs=1M count=100
  - fdisk disk.img, tworzymy tabele partycji DOS i partycje, sektor 512b
  - wlaczamy flage boot (0x55aa na offsecie 0x1fe, nie ma jednak dokumentacji)
  - montujemy nowo stworzona partycje:
    sudo losetup --offset 1048576 -f disk.img
    (offset dla partycji, start sector * sector sz)
  - tworzymy system plikow dla partycji: mkfs.vfat /dev/loop0 (czemu vfat a nie fat?)

  - format MBR (pierwszego sektora) https://wiki.osdev.org/MBR_(x86), https://pl.wikipedia.org/wiki/Master_Boot_Record#/media/File:GNU_GRUB_on_MBR_partitioned_hard_disk_drives.svg
  - MBR zaladowany w 0000:7C00 (http://www.scs.stanford.edu/nyu/04fa/lab/specsbbs101.pdf ???)
  - pierwsze 436 bajtow bootstrap
  - reszta to tabela partycji 
  - https://wiki.osdev.org/MBR_(x86)


- ia32
  - pdf basic architecture:
    - tryby pracy (real, protected: 3.1 Modes of Operation
    - modele zarzadzania pamiecia oferowane przez procesor: 3.3.1 IA-32 memory models

- bios laduje mbr (stage 1) na 0x7c00 - https://wiki.osdev.org/Memory_Map_(x86)
- stage 1 laduje stage 2 uzywajac INT13 ah=42 (extended LBA load) na 0x7e00
- LBA - Logical Block Addressing - https://en.wikipedia.org/wiki/Logical_block_addressing
- adresowanie segment:offset
  - https://en.wikipedia.org/wiki/X86_memory_segmentation
  - https://thestarman.pcministry.com/asm/debug/Segments.html
- maksymalnie 65536 bajtow w real mode co daje 128 blokow - sprawdzone, tak jest

- qemu gdb debug
  - qemu-system-x86_64 -s -S disk.img
  - gdb
  - target remote localhost:1234

- protected mode: programming guide rozdzialy 9.8 i 9.9
  - dobry tutorial http://skelix.net/skelixos/tutorial02_en.html
- Global Descriptior Table:
  - to tabelka definiujaca segmenty pamieci
  - https://en.wikipedia.org/wiki/Global_Descriptor_Table
  - https://wiki.osdev.org/GDT_Tutorial
  - http://www.osdever.net/tutorials/view/the-world-of-protected-mode 
  - dokumentacja Intela - do znalezienia

- Interrupt Descriptor Table:
  - tabelke definiujaca przerwania OSu

- FAT
  - https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system - szczegolowe wyjasnienie
  - https://wiki.osdev.org/FAT - elegancko opisane jak czytac FAT

=================================================================

- Ogolne:
  - https://wiki.osdev.org/What_order_should_I_make_things_in


- GCC cross compiling:
  - jak skompilowac kompilator, GCC cross compiler: https://wiki.osdev.org/GCC_Cross-Compiler
  - jak skompilowac hello world: https://wiki.osdev.org/Bare_Bones
  - przyklad1: https://github.com/stevej/osdev/blob/master/loader/link.ld
  - przyklad2: http://www.osdever.net/bkerndev/Docs/basickernel.htm

- libc/libk
  - ogolnie o implementacjach libc: https://wiki.osdev.org/C_Library
  - newlib: https://wiki.osdev.org/Porting_Newlib
    - syscalls jakie potrzebuje newlib: https://sourceware.org/newlib/libc.html#Syscalls


- I/O
  - screen: https://wiki.osdev.org/Printing_To_Screen
    - 0xb8000 to memory mapped io. moze tez byc io port. https://littleosbook.github.io/#interacting-with-the-hardware
